# -*- coding: utf-8 -*-
"""BancoExercicios

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a6p9cptDQblOFzl4HXfR8xZbAz_oe49O
"""

import numpy as np
import pandas as pd

channels_df = pd.read_csv('/content/channels.csv')
deliveries_df = pd.read_csv('/content/deliveries.csv')
drivers_df = pd.read_csv('/content/drivers.csv')
hubs_df = pd.read_csv('/content/hubs.csv', encoding='ISO-8859-1')
payments_df = pd.read_csv('/content/payments.csv')
stores_df = pd.read_csv('/content/stores.csv', encoding='ISO-8859-1')

df = stores_df
df.head()

valores_nulos = df.isnull().sum()
valores_nulos = valores_nulos[valores_nulos >0].sort_values(ascending=False)

duplicatas = df.duplicated().sum()

tipos_inconsistentes = []

for coluna in df.columns:
    if df[coluna].dtype == 'object':
        try:
            convertido = pd.to_datetime(df[coluna], format='%m/%d/%Y %I:%M:%S %p', errors='coerce')
            if convertido.notnull().mean() > 0.8:
                tipos_inconsistentes.append(coluna)
        except:
            continue

print("üìä Quantidade de valores nulos por coluna:\n", valores_nulos)
print("\nüìë Quantidade de linhas duplicadas:", duplicatas)
print("\n‚ö†Ô∏è Colunas com poss√≠veis tipos inconsistentes (ex: datas como string):", tipos_inconsistentes)



df_limpo = stores_df.copy()

import pandas as pd
import unicodedata

# Fun√ß√£o para padronizar texto
def limpar_texto(texto):
    if pd.isnull(texto):
        return texto
    texto = str(texto).strip().lower()
    texto = unicodedata.normalize('NFKD', texto).encode('ascii', errors='ignore').decode('utf-8')
    return texto

dataframes = {
    "channels_df": channels_df,
    "deliveries_df": deliveries_df,
    "drivers_df": drivers_df,
    "hubs_df": hubs_df,
    "payments_df": payments_df,
    "stores_df": stores_df,
}

for nome, df in dataframes.items():
    for coluna in df.select_dtypes(include=['object', 'string']).columns:
        df[coluna] = df[coluna].apply(limpar_texto)
        print(f"‚úîÔ∏è Limpou: {nome}.{coluna}")

from pandas.api.types import is_numeric_dtype

for nome, df in dataframes.items():
    for coluna in df.columns:

        # Corrigir datas com formato conhecido
        if df[coluna].dtype == 'object':
            amostra = df[coluna].dropna().astype(str).head(10)
            if amostra.str.contains(r'\d{1,2}/\d{1,2}/\d{4} \d{1,2}:\d{2}:\d{2} (AM|PM)', regex=True).any():
                try:
                    df[coluna] = pd.to_datetime(df[coluna], format='%m/%d/%Y %I:%M:%S %p', errors='coerce')
                    print(f"üìÖ Data convertida: {nome}.{coluna}")
                except Exception as e:
                    print(f"‚ö†Ô∏è Erro ao converter data em {nome}.{coluna}: {e}")

if df[coluna].dtype == 'object':
            try:
                # Tenta converter removendo v√≠rgulas e espa√ßos
                df[coluna] = df[coluna].str.replace(',', '').str.strip()
                df[coluna] = pd.to_numeric(df[coluna], errors='ignore')
                if is_numeric_dtype(df[coluna]):
                    print(f"üî¢ Coluna convertida para n√∫mero: {nome}.{coluna}")
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao converter n√∫mero em {nome}.{coluna}: {e}")

import sqlite3
import pandas as pd

# Conectar ao banco de dados em mem√≥ria
conn = sqlite3.connect(":memory:")
cursor = conn.cursor()

# Dropar tabelas e views se j√° existirem para come√ßar do zero
cursor.execute("DROP VIEW IF EXISTS ultima_compra_view;") # Dropar a VIEW antes das tabelas
cursor.execute("DROP TABLE IF EXISTS vendas;")
cursor.execute("DROP TABLE IF EXISTS produtos;")
cursor.execute("DROP TABLE IF EXISTS clientes;")

# Criar as tabelas (incluindo 'data' em vendas)
cursor.execute("""
CREATE TABLE clientes (
  id_cliente INTEGER PRIMARY KEY AUTOINCREMENT,
  nome TEXT,
  email TEXT
);
""")


cursor.execute("""
CREATE TABLE produtos (
  id_produto INTEGER PRIMARY KEY AUTOINCREMENT,
  nome TEXT,
  categoria TEXT,
  pre√ßo REAL
);
""")


cursor.execute("""
CREATE TABLE vendas(
  id_venda INTEGER PRIMARY KEY AUTOINCREMENT,
  id_cliente INTEGER,
  id_produto INTEGER,
  quantidade INTEGER,
  data TEXT, -- Coluna de data (usaremos TEXT para YYYY-MM-DD)
  FOREIGN KEY (id_cliente) REFERENCES clientes(id_cliente),
  FOREIGN KEY (id_produto) REFERENCES produtos(id_produto)
);
""")

# --- Inserir alguns dados de exemplo ---
cursor.execute("INSERT INTO clientes (nome, email) VALUES (?, ?)", ("Cliente A", "a@email.com"))
cursor.execute("INSERT INTO clientes (nome, email) VALUES (?, ?)", ("Cliente B", "b@email.com"))
cursor.execute("INSERT INTO clientes (nome, email) VALUES (?, ?)", ("Cliente C", "c@email.com"))
cursor.execute("INSERT INTO clientes (nome, email) VALUES (?, ?)", ("Cliente D", "d@email.com")) # Cliente sem vendas

cursor.execute("INSERT INTO produtos (nome, categoria, pre√ßo) VALUES (?, ?, ?)", ("Produto X", "Eletr√¥nicos", 550.00))
cursor.execute("INSERT INTO produtos (nome, categoria, pre√ßo) VALUES (?, ?, ?)", ("Produto Y", "Livros", 45.00))
cursor.execute("INSERT INTO produtos (nome, categoria, pre√ßo) VALUES (?, ?, ?)", ("Produto Z", "Eletr√¥nicos", 1200.00))
cursor.execute("INSERT INTO produtos (nome, categoria, pre√ßo) VALUES (?, ?, ?)", ("Produto W", "Livros", 30.00))
cursor.execute("INSERT INTO produtos (nome, categoria, pre√ßo) VALUES (?, ?, ?)", ("Produto K", "Casa", 150.00))

# Inserir vendas (com datas e m√∫ltiplas compras para o mesmo cliente/produto para testar a √∫ltima compra)
cursor.execute("INSERT INTO vendas (id_cliente, id_produto, quantidade, data) VALUES (?, ?, ?, ?)", (1, 1, 1, "2023-01-15")) # Cliente A, Prod X
cursor.execute("INSERT INTO vendas (id_cliente, id_produto, quantidade, data) VALUES (?, ?, ?, ?)", (1, 2, 5, "2023-01-20")) # Cliente A, Prod Y (compra posterior)
cursor.execute("INSERT INTO vendas (id_cliente, id_produto, quantidade, data) VALUES (?, ?, ?, ?)", (1, 1, 2, "2023-01-25")) # Cliente A, Prod X (√∫ltima compra deste produto)

cursor.execute("INSERT INTO vendas (id_cliente, id_produto, quantidade, data) VALUES (?, ?, ?, ?)", (2, 3, 1, "2023-02-10")) # Cliente B, Prod Z
cursor.execute("INSERT INTO vendas (id_cliente, id_produto, quantidade, data) VALUES (?, ?, ?, ?)", (2, 4, 2, "2023-02-12")) # Cliente B, Prod W

cursor.execute("INSERT INTO vendas (id_cliente, id_produto, quantidade, data) VALUES (?, ?, ?, ?)", (3, 2, 1, "2023-03-01")) # Cliente C, Prod Y
cursor.execute("INSERT INTO vendas (id_cliente, id_produto, quantidade, data) VALUES (?, ?, ?, ?)", (3, 4, 3, "2023-03-05")) # Cliente C, Prod W
cursor.execute("INSERT INTO vendas (id_cliente, id_produto, quantidade, data) VALUES (?, ?, ?, ?)", (3, 5, 1, "2023-03-10")) # Cliente C, Prod K

conn.commit() # Salvar as inser√ß√µes

# --- 1. Criar uma VIEW para a √∫ltima compra por Cliente e Produto ---

# Para encontrar a √∫ltima compra por cliente+produto, precisamos usar uma fun√ß√£o de janela
# ou agrupar e encontrar a data m√°xima. Usar uma fun√ß√£o de janela como ROW_NUMBER() ou RANK()
# junto com PARTITION BY e ORDER BY √© a forma mais robusta.

cursor.execute("""
CREATE VIEW ultima_compra_view AS
SELECT
    c.nome AS cliente,
    p.nome AS produto,
    v.data AS data_compra,
    v.quantidade,
    p.pre√ßo,
    (v.quantidade * p.pre√ßo) AS valor_total_item,
    -- Usamos uma fun√ß√£o de janela para numerar as compras de cada cliente+produto
    -- Ordenando pela data em ordem decrescente. A compra mais recente ter√° rank = 1.
    ROW_NUMBER() OVER (PARTITION BY v.id_cliente, v.id_produto ORDER BY v.data DESC, v.id_venda DESC) as rn
FROM vendas v
JOIN clientes c ON v.id_cliente = c.id_cliente
JOIN produtos p ON v.id_produto = p.id_produto
-- A VIEW completa inclui todas as compras com o rank.
-- Para obter apenas a √∫ltima compra, precisaremos filtrar por rn = 1 ao consultar a VIEW.
;
""")
conn.commit()

print("--- Conte√∫do da VIEW 'ultima_compra_view' (mostrando o rank) ---")
# Selecionando todos os dados da VIEW para demonstrar o campo 'rn'
df_view_full = pd.read_sql_query("SELECT * FROM ultima_compra_view LIMIT 10;", conn)
print(df_view_full)

print("\n--- Relat√≥rio: √öltima Compra por Cliente e Produto (usando a VIEW) ---")
# Consultando a VIEW e filtrando para onde o rank √© 1

query_ultima_compra = """
SELECT
    cliente,
    produto,
    data_compra,
    quantidade,
    pre√ßo,
    valor_total_item
FROM ultima_compra_view
WHERE rn = 1
ORDER BY cliente, data_compra DESC;
"""
df_ultima_compra = pd.read_sql_query(query_ultima_compra, conn)
print(df_ultima_compra)

# --- 2. Exemplo de Subquery (Filtrando Clientes com Ticket M√©dio > R$ 300) ---

print("\n--- Relat√≥rio: Clientes com Ticket M√©dio > R$ 300 (usando Subquery) ---")
# Sua consulta original j√° √© um √≥timo exemplo de subquery
# A subquery (a parte interna no FROM) calcula o ticket m√©dio para CADA cliente.
# A consulta externa seleciona a partir dos resultados da subquery (tratada como uma tabela 'sub')
# e aplica a condi√ß√£o WHERE sub.ticket_medio > 300.

query_ticket_maior_300_subquery = """
SELECT nome, ticket_medio
FROM (
    -- Esta √© a subquery: calcula o ticket m√©dio para cada cliente
    SELECT
        c.nome,
        SUM(p.pre√ßo * v.quantidade) * 1.0 / COUNT(v.id_venda) AS ticket_medio
    FROM vendas v
    JOIN clientes c ON v.id_cliente = c.id_cliente
    JOIN produtos p ON v.id_produto = p.id_produto
    GROUP BY c.nome
) AS sub -- 'sub' √© o alias dado ao resultado da subquery, tratando-o como uma tabela
WHERE sub.ticket_medio > 300 -- O filtro √© aplicado no resultado da subquery
ORDER BY sub.ticket_medio DESC;
"""

df_ticket_maior_300_subquery = pd.read_sql_query(query_ticket_maior_300_subquery, conn)
print(df_ticket_maior_300_subquery)

# Fechar a conex√£o ao finalizar
conn.close()



import pandas as pd

# Simulando o conte√∫do da VIEW 'ultima_compra_view' com o ranking
data = {
    'cliente': ['Cliente A', 'Cliente A', 'Cliente A', 'Cliente B', 'Cliente B', 'Cliente C', 'Cliente C', 'Cliente C'],
    'produto': ['Produto X', 'Produto X', 'Produto Y', 'Produto Z', 'Produto W', 'Produto Y', 'Produto W', 'Produto K'],
    'data_compra': ['2023-01-25', '2023-01-15', '2023-01-20', '2023-02-10', '2023-02-12', '2023-03-01', '2023-03-05', '2023-03-10'],
    'quantidade': [2, 1, 5, 1, 2, 1, 3, 1],
    'pre√ßo': [550.0, 550.0, 45.0, 1200.0, 30.0, 45.0, 30.0, 150.0],
    'valor_total_item': [1100.0, 550.0, 225.0, 1200.0, 60.0, 45.0, 90.0, 150.0],
    'rn': [1, 2, 1, 1, 1, 1, 1, 1]
}

df_view = pd.DataFrame(data)

# Mostrando o conte√∫do completo da view com rank
print("\nConte√∫do da VIEW 'ultima_compra_view' (mostrando o rank) ---")
print(df_view)

# Filtrar para mostrar apenas as √∫ltimas compras (rank = 1)
df_ultimas_compras = df_view[df_view['rn'] == 1].copy()
df_ultimas_compras = df_ultimas_compras.sort_values(by=['cliente', 'produto'])

print("\n--- Relat√≥rio: √öltima Compra por Cliente e Produto (usando a VIEW) ---")
print(df_ultimas_compras[['cliente', 'produto', 'data_compra', 'quantidade', 'pre√ßo', 'valor_total_item']])

# Calcular ticket m√©dio por cliente (m√©dia dos valores da √∫ltima compra)
ticket_medio = df_ultimas_compras.groupby('cliente')['valor_total_item'].mean().reset_index()
ticket_medio = ticket_medio.sort_values(by='valor_total_item', ascending=False)
ticket_medio.columns = ['nome', 'ticket_medio']

print("\n--- Ticket M√©dio por Cliente ---")
print(ticket_medio)

'''√öltima Compra por Cliente e Produto
Abaixo est√£o listadas as compras mais recentes feitas por cada cliente para cada produto, considerando apenas a compra mais atual (com rn = 1):

Cliente	Produto	Data da Compra	Quantidade	Pre√ßo Unit√°rio	Valor Total
Cliente A	Produto X	2023-01-25	2	R$ 550,00	R$ 1100,00
Cliente A	Produto Y	2023-01-20	5	R$ 45,00	R$ 225,00
Cliente B	Produto W	2023-02-12	2	R$ 30,00	R$ 60,00
Cliente B	Produto Z	2023-02-10	1	R$ 1200,00	R$ 1200,00
Cliente C	Produto K	2023-03-10	1	R$ 150,00	R$ 150,00
Cliente C	Produto W	2023-03-05	3	R$ 30,00	R$ 90,00
Cliente C	Produto Y	2023-03-01	1	R$ 45,00	R$ 45,00

üí∞ Ticket M√©dio por Cliente
O ticket m√©dio representa o valor m√©dio gasto por compra recente, considerando apenas a √∫ltima compra de cada produto por cliente:

Cliente	Ticket M√©dio
Cliente A	R$ 662,50
Cliente B	R$ 630,00
Cliente C	R$ 95,00

An√°lise:

O Cliente A possui o maior ticket m√©dio, impulsionado principalmente pela compra de dois itens do Produto X com valor elevado.

O Cliente B tamb√©m apresenta um ticket m√©dio alto, com destaque para a aquisi√ß√£o do Produto Z de alto valor unit√°rio.

O Cliente C apresenta o menor ticket m√©dio, concentrando suas compras em produtos de baixo custo e menor quantidade.

üìå Conclus√µes e Insights
Segmenta√ß√£o de clientes por ticket m√©dio pode ajudar a tra√ßar estrat√©gias personalizadas de marketing:

Clientes A e B podem ser classificados como clientes de alto valor, com potencial para campanhas de reten√ß√£o e fideliza√ß√£o.

Cliente C √© um perfil mais econ√¥mico, ideal para campanhas de incentivo √† recorr√™ncia ou combos promocionais.

Produtos de maior valor (como Produto Z e Produto X) influenciam diretamente o ticket m√©dio e devem ser acompanhados de estrat√©gias que reforcem seu valor percebido.

Monitorar a frequ√™ncia de compra por produto pode abrir oportunidades para programas de fidelidade ou vendas cruzadas.
'''

